---
apiVersion: v1
kind: ConfigMap
metadata:
  name: adguard-dns-sync
  namespace: private-services
data:
  sync-dns.sh: |
    #!/bin/sh
    set -e

    # Install jq for JSON parsing
    apk add --no-cache jq > /dev/null 2>&1

    ADGUARD_HOST="${ADGUARD_HOST}"
    ADGUARD_USER="${ADGUARD_USER}"
    ADGUARD_PASS="${ADGUARD_PASS}"
    DEFAULT_INGRESS_IP="${DEFAULT_INGRESS_IP}"
    DOMAIN_SUFFIX="${DOMAIN_SUFFIX}"

    echo "Syncing DNS rewrites to AdGuard Home at ${ADGUARD_HOST}..."
    echo "Default Ingress IP (Traefik): ${DEFAULT_INGRESS_IP}"

    # Get service account token
    TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)

    # Get all hostnames from both standard Ingresses and Traefik IngressRoutes
    echo "Fetching internal ingresses (with internal-ca-issuer or letsencrypt-prod)..."

    # Query standard Ingresses with internal-ca-issuer or letsencrypt-prod
    # Store as JSON objects with host, namespace, and service name
    INGRESS_DATA=$(curl -s -k -H "Authorization: Bearer ${TOKEN}" \
      "https://kubernetes.default.svc/apis/networking.k8s.io/v1/ingresses?limit=500" | \
      jq -c '.items[] | 
        select(.metadata.annotations["cert-manager.io/cluster-issuer"] == "internal-ca-issuer" or 
               .metadata.annotations["cert-manager.io/cluster-issuer"] == "letsencrypt-prod") |
        select(.metadata.annotations["adguard-dns-sync/exclude"] != "true") |
        .metadata.namespace as $ns |
        .spec.rules[] |
        select(.host != null and (.host | endswith("'"${DOMAIN_SUFFIX}"'"))) |
        {
          host: .host,
          namespace: $ns,
          service: .http.paths[0].backend.service.name
        }' 2>/dev/null || echo "")

    # Query Traefik IngressRoutes with internal-ca-issuer or letsencrypt-prod annotation
    INGRESSROUTE_DATA=$(curl -s -k -H "Authorization: Bearer ${TOKEN}" \
      "https://kubernetes.default.svc/apis/traefik.io/v1alpha1/ingressroutes?limit=500" | \
      jq -c '.items[] | 
        select(.metadata.annotations["cert-manager.io/cluster-issuer"] == "internal-ca-issuer" or 
               .metadata.annotations["cert-manager.io/cluster-issuer"] == "letsencrypt-prod") |
        select(.metadata.annotations["adguard-dns-sync/exclude"] != "true") |
        select(.spec.tls.secretName != null) |
        .metadata.namespace as $ns |
        (.spec.routes[]?.services[]?.name // null) as $svc |
        .spec.routes[]? | select(.match != null) |
        .match | 
        capture("Host\\\\(`(?<host>[^`]+)`\\\\)") |
        {
          namespace: $ns,
          service: $svc,
          host: .host
        } |
        select(.host | endswith("'"${DOMAIN_SUFFIX}"'"))' 2>/dev/null || echo "")

    # Combine both sources
    ALL_INGRESS_DATA=$(printf '%s\n%s' "${INGRESS_DATA}" "${INGRESSROUTE_DATA}")

    # Build a map of domain -> IP by checking if service has LoadBalancer
    echo "Resolving target IPs for each domain..."
    
    # Use temp file for domain-ip mapping
    TMP_MAP=$(mktemp)
    
    echo "${ALL_INGRESS_DATA}" | while IFS= read -r LINE; do
      if [ -z "${LINE}" ]; then
        continue
      fi
      
      HOST=$(echo "${LINE}" | jq -r '.host // empty' 2>/dev/null)
      NAMESPACE=$(echo "${LINE}" | jq -r '.namespace // empty' 2>/dev/null)
      SERVICE=$(echo "${LINE}" | jq -r '.service // empty' 2>/dev/null)
      
      if [ -z "${HOST}" ]; then
        continue
      fi
      
      TARGET_IP="${DEFAULT_INGRESS_IP}"
      REASON="default, no service"
      
      if [ -n "${SERVICE}" ] && [ "${SERVICE}" != "null" ] && [ "${SERVICE}" != "empty" ]; then
        # Get service details
        SVC_DATA=$(curl -s -k -H "Authorization: Bearer ${TOKEN}" \
          "https://kubernetes.default.svc/api/v1/namespaces/${NAMESPACE}/services/${SERVICE}" 2>/dev/null)
        
        if [ -n "${SVC_DATA}" ]; then
          SVC_TYPE=$(echo "${SVC_DATA}" | jq -r '.spec.type // empty' 2>/dev/null)
          
          if [ "${SVC_TYPE}" = "LoadBalancer" ]; then
            # Get LoadBalancer IP
            LB_IP=$(echo "${SVC_DATA}" | jq -r '.status.loadBalancer.ingress[0].ip // empty' 2>/dev/null)
            if [ -n "${LB_IP}" ] && [ "${LB_IP}" != "null" ] && [ "${LB_IP}" != "empty" ]; then
              TARGET_IP="${LB_IP}"
              REASON="LoadBalancer"
            else
              REASON="default, LB pending"
            fi
          else
            REASON="default, service type: ${SVC_TYPE}"
          fi
        else
          REASON="default, service not found"
        fi
      fi
      
      echo "  ${HOST} -> ${TARGET_IP} (${REASON})"
      
      # Store in temp file
      echo "${HOST}:${TARGET_IP}" >> "${TMP_MAP}"
    done
    
    # Read map from file
    DOMAIN_IP_MAP=$(cat "${TMP_MAP}" 2>/dev/null || echo "")
    
    # Get unique domains for display
    DOMAINS=$(cat "${TMP_MAP}" 2>/dev/null | cut -d: -f1 | sort -u)

    echo ""
    echo "Found domains (internal + external with split-horizon):"
    echo "${DOMAINS}"
    echo ""

    # Get current rewrites from AdGuard that end with DOMAIN_SUFFIX
    CURRENT_REWRITES=$(curl -s -u "${ADGUARD_USER}:${ADGUARD_PASS}" \
      "http://${ADGUARD_HOST}/control/rewrite/list" | \
      jq -r ".[] | select(.domain | endswith(\"${DOMAIN_SUFFIX}\")) | .domain + \":\" + .answer" | \
      sort -u)

    echo "Current AdGuard rewrites for ${DOMAIN_SUFFIX}:"
    CURRENT_COUNT=$(echo "${CURRENT_REWRITES}" | grep -c . || echo 0)
    echo "Found ${CURRENT_COUNT} existing rewrites"
    echo ""

    # Step 1: Remove orphaned or changed rewrites
    echo "Checking for orphaned or changed rewrites..."
    REMOVED=0
    
    # Use a temp file to avoid subshell issues
    TMP_REMOVED=$(mktemp)
    
    if [ -n "${CURRENT_REWRITES}" ]; then
      echo "${CURRENT_REWRITES}" | while IFS=: read -r CURRENT_DOMAIN CURRENT_IP; do
        if [ -z "${CURRENT_DOMAIN}" ]; then
          continue
        fi
        
        # Check if domain still exists in Kubernetes
        DESIRED_ENTRY=$(grep "^${CURRENT_DOMAIN}:" "${TMP_MAP}" 2>/dev/null || echo "")
        
        if [ -z "${DESIRED_ENTRY}" ]; then
          # Domain no longer exists - remove it
          echo "  âœ— Removing orphaned ${CURRENT_DOMAIN} (${CURRENT_IP})"
          if curl -s -X POST "http://${ADGUARD_HOST}/control/rewrite/delete" \
            -u "${ADGUARD_USER}:${ADGUARD_PASS}" \
            -H "Content-Type: application/json" \
            -d "{\"domain\":\"${CURRENT_DOMAIN}\",\"answer\":\"${CURRENT_IP}\"}" > /dev/null 2>&1; then
            echo "    âœ“ Removed"
            echo "1" >> "${TMP_REMOVED}"
          fi
        else
          # Domain exists - check if IP changed
          DESIRED_IP=$(echo "${DESIRED_ENTRY}" | cut -d: -f2-)
          if [ "${CURRENT_IP}" != "${DESIRED_IP}" ]; then
            echo "  âœ— Updating ${CURRENT_DOMAIN}: ${CURRENT_IP} -> ${DESIRED_IP}"
            if curl -s -X POST "http://${ADGUARD_HOST}/control/rewrite/delete" \
              -u "${ADGUARD_USER}:${ADGUARD_PASS}" \
              -H "Content-Type: application/json" \
              -d "{\"domain\":\"${CURRENT_DOMAIN}\",\"answer\":\"${CURRENT_IP}\"}" > /dev/null 2>&1; then
              echo "    âœ“ Old entry removed"
              echo "1" >> "${TMP_REMOVED}"
            fi
          fi
        fi
      done
      
      REMOVED=$(wc -l < "${TMP_REMOVED}" 2>/dev/null | tr -d ' ' || echo 0)
      rm -f "${TMP_REMOVED}"
    fi
    
    if [ "${REMOVED}" = "0" ]; then
      echo "  No changes needed"
    else
      echo "  Removed/updated: ${REMOVED}"
    fi
    echo ""

    # Step 2: Add new or updated rewrites
    echo "Adding/updating rewrites..."
    TMP_ADDED=$(mktemp)
    TMP_SKIPPED=$(mktemp)
    
    if [ -s "${TMP_MAP}" ]; then
      cat "${TMP_MAP}" | while IFS=: read -r DOMAIN TARGET_IP; do
        if [ -z "${DOMAIN}" ] || [ -z "${TARGET_IP}" ]; then
          continue
        fi
        
        # Check if this exact entry already exists
        if echo "${CURRENT_REWRITES}" | grep -qxF "${DOMAIN}:${TARGET_IP}"; then
          echo "  âœ“ ${DOMAIN} -> ${TARGET_IP} (OK)"
          echo "1" >> "${TMP_SKIPPED}"
        else
          echo "  â†’ Adding ${DOMAIN} -> ${TARGET_IP}"
          if curl -s -X POST "http://${ADGUARD_HOST}/control/rewrite/add" \
            -u "${ADGUARD_USER}:${ADGUARD_PASS}" \
            -H "Content-Type: application/json" \
            -d "{\"domain\":\"${DOMAIN}\",\"answer\":\"${TARGET_IP}\"}" > /dev/null 2>&1; then
            echo "    âœ“ Added"
            echo "1" >> "${TMP_ADDED}"
          else
            echo "    âœ— Failed"
          fi
        fi
      done
      
      ADDED=$(wc -l < "${TMP_ADDED}" 2>/dev/null | tr -d ' ' || echo 0)
      SKIPPED=$(wc -l < "${TMP_SKIPPED}" 2>/dev/null | tr -d ' ' || echo 0)
      rm -f "${TMP_ADDED}" "${TMP_SKIPPED}"
    else
      ADDED=0
      SKIPPED=0
      echo "  No domains to sync"
    fi
    
    # Cleanup temp map file
    rm -f "${TMP_MAP}"

    echo ""
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo "ğŸ“Š Sync Summary:"
    echo "   âœ“ Skipped (unchanged): ${SKIPPED}"
    echo "   â• Added: ${ADDED}"
    echo "   âœ— Removed/Updated: ${REMOVED}"
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo "âœ… AdGuard DNS sync complete!"
---
# PostSync Hook: Runs after every ArgoCD sync
apiVersion: batch/v1
kind: Job
metadata:
  name: adguard-dns-sync-postsync
  namespace: private-services
  annotations:
    argocd.argoproj.io/hook: PostSync
    argocd.argoproj.io/hook-delete-policy: BeforeHookCreation
spec:
  ttlSecondsAfterFinished: 300 # Clean up after 5min
  template:
    spec:
      serviceAccountName: adguard-dns-sync
      restartPolicy: OnFailure
      containers:
        - name: sync
          image: alpine/curl:latest
          command: ["/bin/sh", "/scripts/sync-dns.sh"]
          env:
            - name: ADGUARD_HOST
              value: "192.168.2.9:8080"
            - name: DEFAULT_INGRESS_IP
              value: "192.168.2.250"
            - name: DOMAIN_SUFFIX
              value: "elmstreet79.de"
            - name: ADGUARD_USER
              valueFrom:
                secretKeyRef:
                  name: adguard-credentials
                  key: username
            - name: ADGUARD_PASS
              valueFrom:
                secretKeyRef:
                  name: adguard-credentials
                  key: password
          volumeMounts:
            - name: scripts
              mountPath: /scripts
      volumes:
        - name: scripts
          configMap:
            name: adguard-dns-sync
            defaultMode: 0755
---
# CronJob: Runs every 5 minutes
apiVersion: batch/v1
kind: CronJob
metadata:
  name: adguard-dns-sync
  namespace: private-services
spec:
  schedule: "*/5 * * * *" # Every 5 minutes
  successfulJobsHistoryLimit: 3
  failedJobsHistoryLimit: 3
  jobTemplate:
    spec:
      ttlSecondsAfterFinished: 3600 # Clean up after 1h
      template:
        spec:
          serviceAccountName: adguard-dns-sync
          restartPolicy: OnFailure
          containers:
            - name: sync
              image: alpine/curl:latest
              command: ["/bin/sh", "/scripts/sync-dns.sh"]
              env:
                - name: ADGUARD_HOST
                  value: "192.168.2.9:8080"
                - name: DEFAULT_INGRESS_IP
                  value: "192.168.2.250"
                - name: DOMAIN_SUFFIX
                  value: "elmstreet79.de"
                - name: ADGUARD_USER
                  valueFrom:
                    secretKeyRef:
                      name: adguard-credentials
                      key: username
                - name: ADGUARD_PASS
                  valueFrom:
                    secretKeyRef:
                      name: adguard-credentials
                      key: password
              volumeMounts:
                - name: scripts
                  mountPath: /scripts
          volumes:
            - name: scripts
              configMap:
                name: adguard-dns-sync
                defaultMode: 0755
