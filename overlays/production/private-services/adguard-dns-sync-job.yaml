---
apiVersion: v1
kind: ConfigMap
metadata:
  name: adguard-dns-sync
  namespace: private-services
data:
  sync-dns.sh: |
    #!/bin/sh
    set -e

    # Install jq for JSON parsing
    apk add --no-cache jq > /dev/null 2>&1

    ADGUARD_HOST="${ADGUARD_HOST}"
    ADGUARD_USER="${ADGUARD_USER}"
    ADGUARD_PASS="${ADGUARD_PASS}"
    DEFAULT_INGRESS_IP="${DEFAULT_INGRESS_IP}"
    DOMAIN_SUFFIX="${DOMAIN_SUFFIX}"

    echo "Syncing DNS rewrites to AdGuard Home at ${ADGUARD_HOST}..."
    echo "Default Ingress IP (Traefik): ${DEFAULT_INGRESS_IP}"

    # Get service account token
    TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)

    # Get all hostnames from both standard Ingresses and Traefik IngressRoutes
    echo "Fetching internal ingresses (with internal-ca-issuer or letsencrypt-prod)..."

    # Query standard Ingresses with internal-ca-issuer or letsencrypt-prod
    # Store as JSON objects with host, namespace, and service name
    INGRESS_DATA=$(curl -s -k -H "Authorization: Bearer ${TOKEN}" \
      "https://kubernetes.default.svc/apis/networking.k8s.io/v1/ingresses?limit=500" | \
      jq -c '.items[] | 
        select(.metadata.annotations["cert-manager.io/cluster-issuer"] == "internal-ca-issuer" or 
               .metadata.annotations["cert-manager.io/cluster-issuer"] == "letsencrypt-prod") |
        select(.metadata.annotations["adguard-dns-sync/exclude"] != "true") |
        .metadata.namespace as $ns |
        .spec.rules[] |
        select(.host != null and (.host | endswith("'"${DOMAIN_SUFFIX}"'"))) |
        {
          host: .host,
          namespace: $ns,
          service: .http.paths[0].backend.service.name
        }' 2>/dev/null || echo "")

    # Query Traefik IngressRoutes with internal-ca-issuer or letsencrypt-prod annotation
    INGRESSROUTE_DATA=$(curl -s -k -H "Authorization: Bearer ${TOKEN}" \
      "https://kubernetes.default.svc/apis/traefik.io/v1alpha1/ingressroutes?limit=500" | \
      jq -c ".items[] | 
        select(.metadata.annotations[\"cert-manager.io/cluster-issuer\"] == \"internal-ca-issuer\" or 
               .metadata.annotations[\"cert-manager.io/cluster-issuer\"] == \"letsencrypt-prod\") |
        select(.metadata.annotations[\"adguard-dns-sync/exclude\"] != \"true\") |
        select(.spec.tls.secretName != null) |
        {
          namespace: .metadata.namespace,
          service: (.spec.routes[]?.services[]?.name // null),
          host: (.spec.routes[]? | select(.match != null) | .match | capture(\"Host\\\\\\\\(\\\\\`(?<host>[^\\\\\`]+)\\\\\`\\\\\\\\)\").host)
        } |
        select(.host | endswith(\"${DOMAIN_SUFFIX}\"))")

    # Combine both sources
    ALL_INGRESS_DATA=$(echo "${INGRESS_DATA}"; echo "${INGRESSROUTE_DATA}")

    # Build a map of domain -> IP by checking if service has LoadBalancer
    echo "Resolving target IPs for each domain..."
    DOMAIN_IP_MAP=""
    for LINE in ${ALL_INGRESS_DATA}; do
      HOST=$(echo "${LINE}" | jq -r '.host')
      NAMESPACE=$(echo "${LINE}" | jq -r '.namespace')
      SERVICE=$(echo "${LINE}" | jq -r '.service')
      
      if [ -n "${SERVICE}" ] && [ "${SERVICE}" != "null" ]; then
        # Get service details
        SVC_DATA=$(curl -s -k -H "Authorization: Bearer ${TOKEN}" \
          "https://kubernetes.default.svc/api/v1/namespaces/${NAMESPACE}/services/${SERVICE}")
        
        SVC_TYPE=$(echo "${SVC_DATA}" | jq -r '.spec.type')
        
        if [ "${SVC_TYPE}" = "LoadBalancer" ]; then
          # Get LoadBalancer IP
          LB_IP=$(echo "${SVC_DATA}" | jq -r '.status.loadBalancer.ingress[0].ip // empty')
          if [ -n "${LB_IP}" ]; then
            TARGET_IP="${LB_IP}"
            echo "  ${HOST} -> ${TARGET_IP} (LoadBalancer)"
          else
            TARGET_IP="${DEFAULT_INGRESS_IP}"
            echo "  ${HOST} -> ${TARGET_IP} (default, LB pending)"
          fi
        else
          TARGET_IP="${DEFAULT_INGRESS_IP}"
          echo "  ${HOST} -> ${TARGET_IP} (default)"
        fi
      else
        TARGET_IP="${DEFAULT_INGRESS_IP}"
        echo "  ${HOST} -> ${TARGET_IP} (default, no service)"
      fi
      
      # Store in map as "host:ip"
      DOMAIN_IP_MAP="${DOMAIN_IP_MAP}${HOST}:${TARGET_IP}\n"
    done

    # Get unique domains for comparison
    DOMAINS=$(echo "${DOMAIN_IP_MAP}" | cut -d: -f1 | sort -u)

    echo ""
    echo "Found domains (internal + external with split-horizon):"
    echo "${DOMAINS}"
    echo ""

    # Get current rewrites from AdGuard that end with DOMAIN_SUFFIX
    CURRENT_REWRITES=$(curl -s -u "${ADGUARD_USER}:${ADGUARD_PASS}" \
      "http://${ADGUARD_HOST}/control/rewrite/list" | \
      jq -r ".[] | select(.domain | endswith(\"${DOMAIN_SUFFIX}\")) | .domain + \":\" + .answer" | \
      sort -u)

    echo "Current AdGuard rewrites for ${DOMAIN_SUFFIX}:"
    echo "${CURRENT_REWRITES}"
    echo ""

    # Remove rewrites that are no longer in Kubernetes or have changed IP
    echo "Checking for orphaned or changed rewrites..."
    REMOVED_COUNT=0
    
    if [ -n "${CURRENT_REWRITES}" ]; then
      echo "${CURRENT_REWRITES}" | while IFS= read -r CURRENT_ENTRY; do
        if [ -z "${CURRENT_ENTRY}" ]; then
          continue
        fi
        
        CURRENT_DOMAIN=$(echo "${CURRENT_ENTRY}" | cut -d: -f1)
        CURRENT_IP=$(echo "${CURRENT_ENTRY}" | cut -d: -f2-)
        
        # Check if domain still exists in Kubernetes
        DESIRED_ENTRY=$(echo "${DOMAIN_IP_MAP}" | grep "^${CURRENT_DOMAIN}:")
        
        if [ -z "${DESIRED_ENTRY}" ]; then
          # Domain no longer exists
          echo "âœ— Removing orphaned ${CURRENT_DOMAIN} (${CURRENT_IP})"
          curl -s -X POST "http://${ADGUARD_HOST}/control/rewrite/delete" \
            -u "${ADGUARD_USER}:${ADGUARD_PASS}" \
            -H "Content-Type: application/json" \
            -d "{\"domain\":\"${CURRENT_DOMAIN}\",\"answer\":\"${CURRENT_IP}\"}" > /dev/null
          echo "âœ“ ${CURRENT_DOMAIN} removed"
        else
          # Domain exists, check if IP changed
          DESIRED_IP=$(echo "${DESIRED_ENTRY}" | cut -d: -f2-)
          if [ "${CURRENT_IP}" != "${DESIRED_IP}" ]; then
            echo "âœ— Removing ${CURRENT_DOMAIN} (IP changed: ${CURRENT_IP} -> ${DESIRED_IP})"
            curl -s -X POST "http://${ADGUARD_HOST}/control/rewrite/delete" \
              -u "${ADGUARD_USER}:${ADGUARD_PASS}" \
              -H "Content-Type: application/json" \
              -d "{\"domain\":\"${CURRENT_DOMAIN}\",\"answer\":\"${CURRENT_IP}\"}" > /dev/null
            echo "âœ“ ${CURRENT_DOMAIN} removed (will be re-added)"
          fi
        fi
      done
    else
      echo "No existing rewrites found"
    fi
    echo ""

    # Add new rewrites
    echo "Adding/updating rewrites..."
    ADDED_COUNT=0
    SKIPPED_COUNT=0
    
    if [ -n "${DOMAIN_IP_MAP}" ]; then
      echo "${DOMAIN_IP_MAP}" | while IFS= read -r ENTRY; do
        if [ -z "${ENTRY}" ]; then
          continue
        fi
        
        DOMAIN=$(echo "${ENTRY}" | cut -d: -f1)
        TARGET_IP=$(echo "${ENTRY}" | cut -d: -f2-)
        
        if [ -n "${DOMAIN}" ] && [ -n "${TARGET_IP}" ]; then
          # Check if this exact entry already exists
          if echo "${CURRENT_REWRITES}" | grep -qx "${ENTRY}"; then
            echo "âœ“ ${DOMAIN} -> ${TARGET_IP} already exists"
          else
            echo "â†’ Adding ${DOMAIN} -> ${TARGET_IP}"
            curl -s -X POST "http://${ADGUARD_HOST}/control/rewrite/add" \
              -u "${ADGUARD_USER}:${ADGUARD_PASS}" \
              -H "Content-Type: application/json" \
              -d "{\"domain\":\"${DOMAIN}\",\"answer\":\"${TARGET_IP}\"}" > /dev/null
            echo "âœ“ ${DOMAIN} added"
          fi
        fi
      done
    else
      echo "No domains to add"
    fi

    echo ""
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo "ğŸ“Š Sync Summary:"
    echo "   Domains processed from Kubernetes"
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo "âœ… AdGuard DNS sync complete!"
---
# PostSync Hook: Runs after every ArgoCD sync
apiVersion: batch/v1
kind: Job
metadata:
  name: adguard-dns-sync-postsync
  namespace: private-services
  annotations:
    argocd.argoproj.io/hook: PostSync
    argocd.argoproj.io/hook-delete-policy: BeforeHookCreation
spec:
  ttlSecondsAfterFinished: 300 # Clean up after 5min
  template:
    spec:
      serviceAccountName: adguard-dns-sync
      restartPolicy: OnFailure
      containers:
        - name: sync
          image: alpine/curl:latest
          command: ["/bin/sh", "/scripts/sync-dns.sh"]
          env:
            - name: ADGUARD_HOST
              value: "192.168.2.9:8080"
            - name: DEFAULT_INGRESS_IP
              value: "192.168.2.250"
            - name: DOMAIN_SUFFIX
              value: "elmstreet79.de"
            - name: ADGUARD_USER
              valueFrom:
                secretKeyRef:
                  name: adguard-credentials
                  key: username
            - name: ADGUARD_PASS
              valueFrom:
                secretKeyRef:
                  name: adguard-credentials
                  key: password
          volumeMounts:
            - name: scripts
              mountPath: /scripts
      volumes:
        - name: scripts
          configMap:
            name: adguard-dns-sync
            defaultMode: 0755
---
# CronJob: Runs every 5 minutes
apiVersion: batch/v1
kind: CronJob
metadata:
  name: adguard-dns-sync
  namespace: private-services
spec:
  schedule: "*/5 * * * *" # Every 5 minutes
  successfulJobsHistoryLimit: 3
  failedJobsHistoryLimit: 3
  jobTemplate:
    spec:
      ttlSecondsAfterFinished: 3600 # Clean up after 1h
      template:
        spec:
          serviceAccountName: adguard-dns-sync
          restartPolicy: OnFailure
          containers:
            - name: sync
              image: alpine/curl:latest
              command: ["/bin/sh", "/scripts/sync-dns.sh"]
              env:
                - name: ADGUARD_HOST
                  value: "192.168.2.9:8080"
                - name: DEFAULT_INGRESS_IP
                  value: "192.168.2.250"
                - name: DOMAIN_SUFFIX
                  value: "elmstreet79.de"
                - name: ADGUARD_USER
                  valueFrom:
                    secretKeyRef:
                      name: adguard-credentials
                      key: username
                - name: ADGUARD_PASS
                  valueFrom:
                    secretKeyRef:
                      name: adguard-credentials
                      key: password
              volumeMounts:
                - name: scripts
                  mountPath: /scripts
          volumes:
            - name: scripts
              configMap:
                name: adguard-dns-sync
                defaultMode: 0755
