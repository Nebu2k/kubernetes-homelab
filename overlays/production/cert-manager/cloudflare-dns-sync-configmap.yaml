---
apiVersion: v1
kind: ConfigMap
metadata:
  name: cloudflare-dns-sync
  namespace: cert-manager
data:
  DOMAIN: "elmstreet79.de"
  TARGET: "nebu2k.ipv64.net"
  ZONE_ID: "ee6597dea58f18ca57987dd261e736f4"
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: cloudflare-dns-sync-script
  namespace: cert-manager
data:
  sync-dns.sh: |
    #!/bin/sh
    set -e

    # Install jq for JSON parsing
    apk add --no-cache jq > /dev/null 2>&1

    API_TOKEN="${API_TOKEN}"
    DOMAIN="${DOMAIN}"
    TARGET="${TARGET}"
    ZONE_ID="${ZONE_ID}"

    echo "Syncing public DNS records to Cloudflare for ${DOMAIN}..."
    echo "Target: ${TARGET}"
    echo ""

    # Get service account token
    TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)

    # Get all hostnames from both standard Ingresses and Traefik IngressRoutes
    echo "Fetching public ingresses (with letsencrypt-prod)..."

    # Query standard Ingresses
    INGRESS_DATA=$(curl -s -k -H "Authorization: Bearer ${TOKEN}" \
      "https://kubernetes.default.svc/apis/networking.k8s.io/v1/ingresses?limit=500" | \
      jq -r ".items[] | 
        select(.metadata.annotations[\"cert-manager.io/cluster-issuer\"] == \"letsencrypt-prod\") | 
        {
          host: .spec.rules[]?.host,
          proxied: (.metadata.annotations[\"cloudflare.io/proxied\"] // \"true\")
        } | 
        select(.host != null and (.host | endswith(\"${DOMAIN}\")))")

    # Query Traefik IngressRoutes with letsencrypt-prod annotation
    INGRESSROUTE_DATA=$(curl -s -k -H "Authorization: Bearer ${TOKEN}" \
      "https://kubernetes.default.svc/apis/traefik.io/v1alpha1/ingressroutes?limit=500" | \
      jq -r ".items[] | 
        select(.metadata.annotations[\"cert-manager.io/cluster-issuer\"] == \"letsencrypt-prod\") |
        select(.spec.tls.secretName != null) |
        {
          routes: .spec.routes,
          proxied: (.metadata.annotations[\"cloudflare.io/proxied\"] // \"true\")
        } |
        .routes[].match | 
        select(. != null) | 
        scan(\"Host\\\\(\\\\\`([^\\\\\`]+)\\\\\`\\\\)\")[0] |
        {host: ., proxied: \"true\"} |
        select(.host | endswith(\"${DOMAIN}\"))")

    # Combine both sources
    ALL_DOMAINS=$(echo "${INGRESS_DATA}"; echo "${INGRESSROUTE_DATA}")

    echo "Found public domains:"
    echo "${ALL_DOMAINS}" | jq -r '.host' | sort -u
    echo ""

    # Get existing DNS records from Cloudflare
    echo "Fetching existing DNS records from Cloudflare..."
    EXISTING_RECORDS=$(curl -s -X GET "https://api.cloudflare.com/client/v4/zones/${ZONE_ID}/dns_records?type=CNAME&per_page=100" \
      -H "Authorization: Bearer ${API_TOKEN}" \
      -H "Content-Type: application/json")

    # Check if the API call was successful
    SUCCESS=$(echo "${EXISTING_RECORDS}" | jq -r '.success')
    if [ "$SUCCESS" != "true" ]; then
      echo "‚ùå Error fetching DNS records from Cloudflare:"
      echo "${EXISTING_RECORDS}" | jq -r '.errors[].message'
      exit 1
    fi

    # Filter records that point to our TARGET and end with our DOMAIN
    CLOUDFLARE_DOMAINS=$(echo "${EXISTING_RECORDS}" | \
      jq -r ".result[] | select(.content == \"${TARGET}\" and (.name | endswith(\"${DOMAIN}\"))) | .name" | \
      sort -u)

    echo "Current Cloudflare CNAME records pointing to ${TARGET}:"
    echo "${CLOUDFLARE_DOMAINS}"
    echo ""

    # Remove DNS records that are no longer in Kubernetes
    echo "Checking for orphaned DNS records..."
    ORPHANED_COUNT=0
    for CF_DOMAIN in ${CLOUDFLARE_DOMAINS}; do
      if ! echo "${ALL_DOMAINS}" | jq -e "select(.host == \"${CF_DOMAIN}\")" > /dev/null 2>&1; then
        echo "‚úó Removing orphaned ${CF_DOMAIN}"
        
        # Get record ID
        RECORD_ID=$(echo "${EXISTING_RECORDS}" | jq -r ".result[] | select(.name == \"${CF_DOMAIN}\") | .id")
        
        if [ -n "${RECORD_ID}" ]; then
          DELETE_RESULT=$(curl -s -X DELETE "https://api.cloudflare.com/client/v4/zones/${ZONE_ID}/dns_records/${RECORD_ID}" \
            -H "Authorization: Bearer ${API_TOKEN}" \
            -H "Content-Type: application/json")
          
          DELETE_SUCCESS=$(echo "${DELETE_RESULT}" | jq -r '.success')
          if [ "$DELETE_SUCCESS" = "true" ]; then
            echo "‚úì ${CF_DOMAIN} removed"
            ORPHANED_COUNT=$((ORPHANED_COUNT + 1))
          else
            echo "‚ö†Ô∏è  Failed to remove ${CF_DOMAIN}"
            echo "${DELETE_RESULT}" | jq -r '.errors[].message'
          fi
        fi
      fi
    done
    
    if [ ${ORPHANED_COUNT} -eq 0 ]; then
      echo "No orphaned records found"
    fi
    echo ""

    # Add or update DNS records for all ingress domains
    echo "Adding/updating DNS records..."
    ADDED_COUNT=0
    UPDATED_COUNT=0
    SKIPPED_COUNT=0
    
    echo "${ALL_DOMAINS}" | jq -c '.' | while read -r ingress_entry; do
      INGRESS_DOMAIN=$(echo "${ingress_entry}" | jq -r '.host')
      PROXIED=$(echo "${ingress_entry}" | jq -r '.proxied')
      
      if [ -z "${INGRESS_DOMAIN}" ]; then
        continue
      fi

      # Check if record already exists
      EXISTING_RECORD=$(echo "${EXISTING_RECORDS}" | jq -r ".result[] | select(.name == \"${INGRESS_DOMAIN}\")")
      
      if [ -n "${EXISTING_RECORD}" ]; then
        # Check if it points to the correct target and has correct proxy setting
        CURRENT_TARGET=$(echo "${EXISTING_RECORD}" | jq -r '.content')
        CURRENT_PROXIED=$(echo "${EXISTING_RECORD}" | jq -r '.proxied')
        
        if [ "${CURRENT_TARGET}" = "${TARGET}" ] && [ "${CURRENT_PROXIED}" = "${PROXIED}" ]; then
          echo "‚úì ${INGRESS_DOMAIN} already exists and is correct (proxied: ${PROXIED})"
          SKIPPED_COUNT=$((SKIPPED_COUNT + 1))
        else
          # Update existing record
          echo "üîÑ Updating ${INGRESS_DOMAIN} (target: ${CURRENT_TARGET} -> ${TARGET}, proxied: ${CURRENT_PROXIED} -> ${PROXIED})"
          RECORD_ID=$(echo "${EXISTING_RECORD}" | jq -r '.id')
          
          UPDATE_RESULT=$(curl -s -X PUT "https://api.cloudflare.com/client/v4/zones/${ZONE_ID}/dns_records/${RECORD_ID}" \
            -H "Authorization: Bearer ${API_TOKEN}" \
            -H "Content-Type: application/json" \
            --data "{\"type\":\"CNAME\",\"name\":\"${INGRESS_DOMAIN}\",\"content\":\"${TARGET}\",\"ttl\":1,\"proxied\":${PROXIED}}")
          
          UPDATE_SUCCESS=$(echo "${UPDATE_RESULT}" | jq -r '.success')
          if [ "$UPDATE_SUCCESS" = "true" ]; then
            echo "‚úì ${INGRESS_DOMAIN} updated"
            UPDATED_COUNT=$((UPDATED_COUNT + 1))
          else
            echo "‚ö†Ô∏è  Failed to update ${INGRESS_DOMAIN}"
            echo "${UPDATE_RESULT}" | jq -r '.errors[].message'
          fi
        fi
      else
        # Create new record
        echo "‚Üí Adding ${INGRESS_DOMAIN} -> ${TARGET} (proxied: ${PROXIED})"
        
        CREATE_RESULT=$(curl -s -X POST "https://api.cloudflare.com/client/v4/zones/${ZONE_ID}/dns_records" \
          -H "Authorization: Bearer ${API_TOKEN}" \
          -H "Content-Type: application/json" \
          --data "{\"type\":\"CNAME\",\"name\":\"${INGRESS_DOMAIN}\",\"content\":\"${TARGET}\",\"ttl\":1,\"proxied\":${PROXIED}}")
        
        CREATE_SUCCESS=$(echo "${CREATE_RESULT}" | jq -r '.success')
        if [ "$CREATE_SUCCESS" = "true" ]; then
          echo "‚úì ${INGRESS_DOMAIN} added"
          ADDED_COUNT=$((ADDED_COUNT + 1))
        else
          echo "‚ö†Ô∏è  Failed to add ${INGRESS_DOMAIN}"
          echo "${CREATE_RESULT}" | jq -r '.errors[].message'
        fi
      fi
    done

    echo ""
    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
    echo "üìä Sync Summary:"
    echo "   ‚úì Skipped (already correct): ${SKIPPED_COUNT}"
    echo "   ‚ûï Added: ${ADDED_COUNT}"
    echo "   üîÑ Updated: ${UPDATED_COUNT}"
    echo "   ‚úó Removed: ${ORPHANED_COUNT}"
    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
    echo "‚úÖ Cloudflare DNS sync complete!"
  
  watcher.sh: |
    #!/bin/sh
    set -e
    
    echo "üîç Starting Cloudflare DNS Sync Controller..."
    echo "   Watching for Ingresses with: cert-manager.io/cluster-issuer=letsencrypt-prod"
    echo ""
    
    # Get service account token
    TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)
    
    # Function to trigger sync
    trigger_sync() {
      echo "‚ö° Triggering DNS sync at $(date '+%Y-%m-%d %H:%M:%S')..."
      if /scripts/sync-dns.sh; then
        echo "‚úÖ Sync completed successfully"
        return 0
      else
        echo "‚ùå Sync failed"
        return 1
      fi
    }
    
    # Initial sync on startup
    echo "üöÄ Running initial sync..."
    trigger_sync || echo "‚ö†Ô∏è  Initial sync failed, will retry on events"
    echo ""
    
    # Retry logic with exponential backoff
    RETRY_COUNT=0
    MAX_RETRIES=5
    BACKOFF=1
    
    while true; do
      echo "üëÄ Starting Ingress watch (attempt $((RETRY_COUNT + 1)))..."
      
      # Watch for ingress changes with timeout handling
      if curl -N -s -k -H "Authorization: Bearer ${TOKEN}" \
        --max-time 0 \
        "https://kubernetes.default.svc/apis/networking.k8s.io/v1/ingresses?watch=true" | \
      while read -r line; do
        # Skip empty lines
        [ -z "${line}" ] && continue
        
        # Check for error responses
        if echo "${line}" | grep -q '"type":"ERROR"'; then
          echo "‚ö†Ô∏è  Received ERROR event from API server"
          echo "${line}"
          exit 1
        fi
        
        # Parse event
        EVENT_TYPE=$(echo "${line}" | jq -r '.type // empty' 2>/dev/null)
        
        # Skip if we can't parse the event
        [ -z "${EVENT_TYPE}" ] && continue
        
        # Check if this ingress has letsencrypt-prod annotation
        HAS_ANNOTATION=$(echo "${line}" | jq -r 'select(.object.metadata.annotations["cert-manager.io/cluster-issuer"] == "letsencrypt-prod") | .type' 2>/dev/null)
        
        if [ -n "${HAS_ANNOTATION}" ]; then
          INGRESS_NAME=$(echo "${line}" | jq -r '.object.metadata.name // "unknown"')
          INGRESS_NS=$(echo "${line}" | jq -r '.object.metadata.namespace // "unknown"')
          
          echo ""
          echo "üì° Detected ${EVENT_TYPE} event: ${INGRESS_NS}/${INGRESS_NAME}"
          
          # Trigger sync and reset retry counter on success
          if trigger_sync; then
            RETRY_COUNT=0
            BACKOFF=1
          fi
          echo ""
        fi
      done; then
        # Watch completed successfully (shouldn't happen unless connection closed)
        echo "‚ö†Ô∏è  Watch connection closed, reconnecting..."
        RETRY_COUNT=0
        BACKOFF=1
        sleep 2
      else
        # Watch failed
        RETRY_COUNT=$((RETRY_COUNT + 1))
        
        if [ ${RETRY_COUNT} -ge ${MAX_RETRIES} ]; then
          echo "‚ùå Max retries (${MAX_RETRIES}) reached, resetting counter and continuing..."
          RETRY_COUNT=0
          BACKOFF=1
        fi
        
        echo "‚ö†Ô∏è  Watch failed, retrying in ${BACKOFF}s..."
        sleep ${BACKOFF}
        
        # Exponential backoff: 1, 2, 4, 8, 16 seconds (max)
        BACKOFF=$((BACKOFF * 2))
        [ ${BACKOFF} -gt 16 ] && BACKOFF=16
      fi
    done

