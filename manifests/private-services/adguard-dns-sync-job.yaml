---
apiVersion: v1
kind: ConfigMap
metadata:
  name: adguard-dns-sync
  namespace: private-services
data:
  sync-dns.sh: |
    #!/bin/sh
    set -e

    # Install jq for JSON parsing
    apk add --no-cache jq > /dev/null 2>&1

    ADGUARD_HOST="${ADGUARD_HOST}"
    ADGUARD_USER="${ADGUARD_USER}"
    ADGUARD_PASS="${ADGUARD_PASS}"
    DEFAULT_INGRESS_IP="${DEFAULT_INGRESS_IP}"
    DEFAULT_INGRESS_IP_V6="${DEFAULT_INGRESS_IP_V6}"
    DOMAIN_SUFFIX="${DOMAIN_SUFFIX}"

    echo "Syncing DNS rewrites to AdGuard Home at ${ADGUARD_HOST}..."
    echo "Default Ingress IPv4 (Traefik): ${DEFAULT_INGRESS_IP}"
    echo "Default Ingress IPv6 (Traefik): ${DEFAULT_INGRESS_IP_V6}"

    # Get service account token
    TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)

    # Get all hostnames from Kubernetes Ingresses and Traefik IngressRoutes
    echo "Fetching internal routes (Ingress + IngressRoute)..."

    # Query standard Ingresses with internal-ca-issuer or letsencrypt-prod
    # Store as JSON objects with host, namespace, and service name
    INGRESS_DATA=$(curl -s -k -H "Authorization: Bearer ${TOKEN}" \
      "https://kubernetes.default.svc/apis/networking.k8s.io/v1/ingresses?limit=500" | \
      jq -c '.items[] | 
        select(.metadata.annotations["cert-manager.io/cluster-issuer"] == "internal-ca-issuer" or 
               .metadata.annotations["cert-manager.io/cluster-issuer"] == "letsencrypt-prod") |
        select(.metadata.annotations["adguard-dns-sync/exclude"] != "true") |
        .metadata.namespace as $ns |
        .spec.rules[] |
        select(.host != null and (.host | endswith("'""${DOMAIN_SUFFIX}""'"))) |
        {
          host: .host,
          namespace: $ns,
          service: .http.paths[0].backend.service.name
        }' 2>/dev/null || echo "")

    # Query Traefik IngressRoutes (CRD) and extract Host(`...`) match rules
    # Store as JSON objects with host, namespace, and service name
    INGRESSROUTE_DATA=$(curl -s -k -H "Authorization: Bearer ${TOKEN}" \
      "https://kubernetes.default.svc/apis/traefik.io/v1alpha1/ingressroutes?limit=500" | \
      jq -c '.items[] |
        select(.metadata.annotations["adguard-dns-sync/exclude"] != "true") |
        .metadata.namespace as $ns |
        (.spec.routes // [])[]? as $route |
        ($route.match // "") as $match |
        (try ($match | capture("Host\\(`(?<host>[^`]+)`\\)")) catch null) as $cap |
        select($cap != null) |
        ($cap.host // empty) as $host |
        select($host != null and ($host | endswith("'""${DOMAIN_SUFFIX}""'"))) |
        {
          host: $host,
          namespace: $ns,
          service: ($route.services[0].name // "null")
        }' 2>/dev/null || echo "")

    ALL_INGRESS_DATA=$( (echo "${INGRESS_DATA}"; echo "${INGRESSROUTE_DATA}") | sed '/^$/d' )

    INGRESS_COUNT=$(echo "${INGRESS_DATA}" | grep -c . || echo 0)
    INGRESSROUTE_COUNT=$(echo "${INGRESSROUTE_DATA}" | grep -c . || echo 0)
    TOTAL_COUNT=$(echo "${ALL_INGRESS_DATA}" | grep -c . || echo 0)
    echo "Found ${TOTAL_COUNT} routes (${INGRESS_COUNT} Ingress, ${INGRESSROUTE_COUNT} IngressRoute)"

    # Build maps of domain -> IP (both IPv4 and IPv6) by checking if service has LoadBalancer
    echo "Resolving target IPs for each domain..."
    echo ""

    # Use temp files for domain-ip mappings
    TMP_MAP_V4=$(mktemp)
    TMP_MAP_V6=$(mktemp)

    while IFS= read -r LINE; do
      if [ -z "${LINE}" ]; then
        continue
      fi

      HOST=$(echo "${LINE}" | jq -r '.host // empty' 2>/dev/null)
      NAMESPACE=$(echo "${LINE}" | jq -r '.namespace // empty' 2>/dev/null)
      SERVICE=$(echo "${LINE}" | jq -r '.service // empty' 2>/dev/null)

      if [ -z "${HOST}" ]; then
        continue
      fi

      # Skip if already processed (avoid duplicates)
      if grep -q "^${HOST}:" "${TMP_MAP_V4}" 2>/dev/null; then
        echo "  ${HOST} -> (skipped, duplicate)"
        continue
      fi

      TARGET_IP_V4="${DEFAULT_INGRESS_IP}"
      TARGET_IP_V6="${DEFAULT_INGRESS_IP_V6}"
      REASON="default"

      # Skip special Traefik internal services
      if [ "${SERVICE}" = "api@internal" ] || [ -z "${SERVICE}" ] || [ "${SERVICE}" = "null" ]; then
        echo "  ${HOST} -> IPv4: ${TARGET_IP_V4}, IPv6: ${TARGET_IP_V6} (${REASON}, no k8s service)"
        echo "${HOST}:${TARGET_IP_V4}" >> "${TMP_MAP_V4}"
        [ -n "${TARGET_IP_V6}" ] && echo "${HOST}:${TARGET_IP_V6}" >> "${TMP_MAP_V6}"
        continue
      fi

      # Get service details
      SVC_DATA=$(curl -s -k -H "Authorization: Bearer ${TOKEN}" \
        "https://kubernetes.default.svc/api/v1/namespaces/${NAMESPACE}/services/${SERVICE}")

      SVC_KIND=$(echo "${SVC_DATA}" | jq -r '.kind // empty' 2>/dev/null)

      if [ "${SVC_KIND}" = "Service" ]; then
        SVC_TYPE=$(echo "${SVC_DATA}" | jq -r '.spec.type' 2>/dev/null)

        if [ "${SVC_TYPE}" = "LoadBalancer" ]; then
          # Get LoadBalancer IPs (dual-stack may have multiple ingress entries)
          LB_IPS=$(echo "${SVC_DATA}" | jq -r '.status.loadBalancer.ingress[].ip // empty' 2>/dev/null)

          if [ -n "${LB_IPS}" ]; then
            # Separate IPv4 and IPv6 addresses
            for IP in ${LB_IPS}; do
              if echo "${IP}" | grep -q ':'; then
                # IPv6 address
                TARGET_IP_V6="${IP}"
              else
                # IPv4 address
                TARGET_IP_V4="${IP}"
              fi
            done
            REASON="LoadBalancer"
          else
            REASON="LB pending"
          fi
        else
          REASON="${SVC_TYPE}"
        fi
      else
        ERROR_MSG=$(echo "${SVC_DATA}" | jq -r '.message // "not found"' 2>/dev/null)
        REASON="error: ${ERROR_MSG}"
      fi

      echo "  ${HOST} -> IPv4: ${TARGET_IP_V4}, IPv6: ${TARGET_IP_V6} (${REASON})"
      echo "${HOST}:${TARGET_IP_V4}" >> "${TMP_MAP_V4}"
      [ -n "${TARGET_IP_V6}" ] && echo "${HOST}:${TARGET_IP_V6}" >> "${TMP_MAP_V6}"
    done < <(echo "${ALL_INGRESS_DATA}")

    # Get unique domains for display
    DOMAINS=$(cat "${TMP_MAP_V4}" 2>/dev/null | cut -d: -f1 | sort -u)

    echo ""
    echo "DNS sync targets:"
    echo "${DOMAINS}"
    echo ""

    # Helper function to sync DNS rewrites for a given IP family
    sync_dns_rewrites() {
      local RECORD_TYPE="$1"    # "A" or "AAAA"
      local MAP_FILE="$2"       # Path to temp map file
      local IP_FAMILY="$3"      # "IPv4" or "IPv6"

      echo "Adding/updating ${IP_FAMILY} (${RECORD_TYPE}) rewrites..."
      local TMP_ADDED=$(mktemp)
      local TMP_SKIPPED=$(mktemp)
      local ADDED=0
      local SKIPPED=0

      if [ -s "${MAP_FILE}" ]; then
        while IFS=: read -r DOMAIN TARGET_IP; do
          if [ -z "${DOMAIN}" ] || [ -z "${TARGET_IP}" ]; then
            continue
          fi

          # Check if this exact entry already exists
          if echo "${CURRENT_REWRITES}" | grep -qxF "${DOMAIN}:${TARGET_IP}"; then
            echo "  âœ“ ${DOMAIN} -> ${TARGET_IP} (OK, ${RECORD_TYPE})"
            echo "1" >> "${TMP_SKIPPED}"
          else
            echo "  â†’ Adding ${DOMAIN} -> ${TARGET_IP} (${RECORD_TYPE})"
            if curl -s -X POST "http://${ADGUARD_HOST}/control/rewrite/add" \
              -u "${ADGUARD_USER}:${ADGUARD_PASS}" \
              -H "Content-Type: application/json" \
              -d "{\"domain\":\"${DOMAIN}\",\"answer\":\"${TARGET_IP}\"}" > /dev/null 2>&1; then
              echo "    âœ“ Added"
              echo "1" >> "${TMP_ADDED}"
            else
              echo "    âœ— Failed"
            fi
          fi
        done < "${MAP_FILE}"

        ADDED=$(wc -l < "${TMP_ADDED}" 2>/dev/null | tr -d ' ' || echo 0)
        SKIPPED=$(wc -l < "${TMP_SKIPPED}" 2>/dev/null | tr -d ' ' || echo 0)
        rm -f "${TMP_ADDED}" "${TMP_SKIPPED}"
      else
        echo "  No domains to sync for ${IP_FAMILY}"
      fi

      # Return counts via global variables (shell function limitation)
      eval "${RECORD_TYPE}_ADDED=${ADDED}"
      eval "${RECORD_TYPE}_SKIPPED=${SKIPPED}"
    }

    # Get current rewrites from AdGuard that end with DOMAIN_SUFFIX
    CURRENT_REWRITES=$(curl -s -u "${ADGUARD_USER}:${ADGUARD_PASS}" \
      "http://${ADGUARD_HOST}/control/rewrite/list" | \
      jq -r ".[] | select(.domain | endswith(\"${DOMAIN_SUFFIX}\")) | .domain + \":\" + .answer" | \
      sort -u)

    echo "Current AdGuard rewrites for ${DOMAIN_SUFFIX}:"
    CURRENT_COUNT=$(echo "${CURRENT_REWRITES}" | grep -c . || echo 0)
    echo "Found ${CURRENT_COUNT} existing rewrites"
    echo ""

    # Step 1: Remove orphaned or changed rewrites
    echo "Checking for orphaned or changed rewrites..."
    REMOVED=0

    # Use a temp file to avoid subshell issues
    TMP_REMOVED=$(mktemp)

    if [ -n "${CURRENT_REWRITES}" ]; then
      while IFS=: read -r CURRENT_DOMAIN CURRENT_IP; do
        if [ -z "${CURRENT_DOMAIN}" ]; then
          continue
        fi

        # Check if domain+IP combo still exists in either IPv4 or IPv6 map
        DESIRED_ENTRY_V4=$(grep "^${CURRENT_DOMAIN}:" "${TMP_MAP_V4}" 2>/dev/null || echo "")
        DESIRED_ENTRY_V6=$(grep "^${CURRENT_DOMAIN}:" "${TMP_MAP_V6}" 2>/dev/null || echo "")

        # Combine both entries
        DESIRED_ENTRIES="${DESIRED_ENTRY_V4}"$'\n'"${DESIRED_ENTRY_V6}"

        # Check if this specific domain+IP combination is desired
        if ! echo "${DESIRED_ENTRIES}" | grep -qxF "${CURRENT_DOMAIN}:${CURRENT_IP}"; then
          # This specific IP for domain no longer exists - remove it
          echo "  âœ— Removing ${CURRENT_DOMAIN} (${CURRENT_IP})"
          if curl -s -X POST "http://${ADGUARD_HOST}/control/rewrite/delete" \
            -u "${ADGUARD_USER}:${ADGUARD_PASS}" \
            -H "Content-Type: application/json" \
            -d "{\"domain\":\"${CURRENT_DOMAIN}\",\"answer\":\"${CURRENT_IP}\"}" > /dev/null 2>&1; then
            echo "    âœ“ Removed"
            echo "1" >> "${TMP_REMOVED}"
          fi
        fi
      done < <(echo "${CURRENT_REWRITES}")

      REMOVED=$(wc -l < "${TMP_REMOVED}" 2>/dev/null | tr -d ' ' || echo 0)
      rm -f "${TMP_REMOVED}"
    fi

    if [ "${REMOVED}" = "0" ]; then
      echo "  No changes needed"
    else
      echo "  Removed/updated: ${REMOVED}"
    fi
    echo ""

    # Step 2: Sync IPv4 (A) records
    sync_dns_rewrites "A" "${TMP_MAP_V4}" "IPv4"
    echo ""

    # Step 3: Sync IPv6 (AAAA) records
    sync_dns_rewrites "AAAA" "${TMP_MAP_V6}" "IPv6"

    # Cleanup temp map files
    rm -f "${TMP_MAP_V4}" "${TMP_MAP_V6}"

    echo ""
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo "ğŸ“Š Sync Summary:"
    echo "   IPv4 (A Records):"
    echo "     âœ“ Skipped (unchanged): ${A_SKIPPED}"
    echo "     â• Added: ${A_ADDED}"
    echo "   IPv6 (AAAA Records):"
    echo "     âœ“ Skipped (unchanged): ${AAAA_SKIPPED}"
    echo "     â• Added: ${AAAA_ADDED}"
    echo "   Removed/Updated: ${REMOVED}"
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo "âœ… AdGuard DNS sync complete!"
---
# PostSync Hook: Runs after every ArgoCD sync
apiVersion: batch/v1
kind: Job
metadata:
  name: adguard-dns-sync-postsync
  namespace: private-services
  annotations:
    argocd.argoproj.io/hook: PostSync
    argocd.argoproj.io/hook-delete-policy: BeforeHookCreation
spec:
  ttlSecondsAfterFinished: 300 # Clean up after 5min
  template:
    spec:
      serviceAccountName: adguard-dns-sync
      restartPolicy: OnFailure
      containers:
        - name: sync
          image: alpine/curl:8.17.0
          command: ["/bin/sh", "/scripts/sync-dns.sh"]
          env:
            - name: ADGUARD_HOST
              value: "192.168.2.16"
            - name: DEFAULT_INGRESS_IP
              value: "192.168.2.250"
            - name: DEFAULT_INGRESS_IP_V6
              value: "fd00:cafe:beef::250"
            - name: DOMAIN_SUFFIX
              value: "elmstreet79.de"
            - name: ADGUARD_USER
              valueFrom:
                secretKeyRef:
                  name: adguard-credentials
                  key: username
            - name: ADGUARD_PASS
              valueFrom:
                secretKeyRef:
                  name: adguard-credentials
                  key: password
          volumeMounts:
            - name: scripts
              mountPath: /scripts
      volumes:
        - name: scripts
          configMap:
            name: adguard-dns-sync
            defaultMode: 0755
---
# CronJob: Runs every 5 minutes
apiVersion: batch/v1
kind: CronJob
metadata:
  name: adguard-dns-sync
  namespace: private-services
spec:
  schedule: "*/5 * * * *" # Every 5 minutes
  successfulJobsHistoryLimit: 3
  failedJobsHistoryLimit: 3
  jobTemplate:
    spec:
      ttlSecondsAfterFinished: 3600 # Clean up after 1h
      template:
        spec:
          serviceAccountName: adguard-dns-sync
          restartPolicy: OnFailure
          containers:
            - name: sync
              image: alpine/curl:8.17.0
              command: ["/bin/sh", "/scripts/sync-dns.sh"]
              env:
                - name: ADGUARD_HOST
                  value: "192.168.2.16"
                - name: DEFAULT_INGRESS_IP
                  value: "192.168.2.250"
                - name: DEFAULT_INGRESS_IP_V6
                  value: "fd00:cafe:beef::250"
                - name: DOMAIN_SUFFIX
                  value: "elmstreet79.de"
                - name: ADGUARD_USER
                  valueFrom:
                    secretKeyRef:
                      name: adguard-credentials
                      key: username
                - name: ADGUARD_PASS
                  valueFrom:
                    secretKeyRef:
                      name: adguard-credentials
                      key: password
              volumeMounts:
                - name: scripts
                  mountPath: /scripts
          volumes:
            - name: scripts
              configMap:
                name: adguard-dns-sync
                defaultMode: 0755
